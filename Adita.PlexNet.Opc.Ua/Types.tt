<#@ template debug="false" hostspecific="true" language="C#"
#><#@ assembly name="System.Core" 
#><#@ import namespace="System.Linq" 
#><#@ import namespace="System.Text" 
#><#@ import namespace="System.Collections.Generic" 
#><#@ assembly name="System.Xml.dll" 
#><#@ import namespace="System.Xml" 
#><#@ import namespace="System.IO" 
#><#@ import namespace="System.CodeDom" 
#><#@ import namespace="System.Xml.Schema" 
#><#@ import namespace="System.Xml.Serialization"
#><#@ output extension="generated.cs" 
#><#  
var filename = this.Host.ResolvePath(@"Schemas\Types.xsd");
var ns = new CodeNamespace();
XmlReader reader = null;
try
{
    XmlSchema xsd;
    var schemas = new XmlSchemas();

    reader = XmlReader.Create(filename);
    xsd = XmlSchema.Read(reader, null);

    var schemaSet = new XmlSchemaSet();
    schemaSet.Add(xsd);
    schemaSet.Compile();

    foreach (XmlSchema schema in schemaSet.Schemas())
    {
        schemas.Add(schema);
    }

    var exporter = new XmlCodeExporter(ns);
    var importer = new XmlSchemaImporter(schemas, CodeGenerationOptions.None, new ImportContext(new CodeIdentifiers(), false));

    foreach (XmlSchemaElement element in xsd.Elements.Values)
    {
        var mapping = importer.ImportTypeMapping(element.QualifiedName);
        exporter.ExportTypeMapping(mapping);
    }

    UaClasses = ns
        .Types
        .OfType<CodeTypeDeclaration>()
        .Where(tt=>tt.IsClass && !tt.Name.StartsWith("ListOf") && tt.Name != "StatusCode" && tt.Name != "Variant" && tt.Name != "Guid")
        .Select(tt => tt.Name)
        .ToHashSet();
#>// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 15.0.0.0
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

// Auto-generated code requires an explicit `#nullable` directive in source.
#nullable enable

using MediatR;
using Adita.PlexNet.Opc.Ua.Annotations;
using Adita.PlexNet.Opc.Ua.Abstractions.Encodables;
using Adita.PlexNet.Opc.Ua.Abstractions.Encoders;
using Adita.PlexNet.Opc.Ua.Abstractions.Decoders;
using Adita.PlexNet.Opc.Ua.Abstractions.Requests;
using Adita.PlexNet.Opc.Ua.Abstractions.Responses;

[assembly: TypeLibrary()]
namespace Adita.PlexNet.Opc.Ua
{
    using System;
    using System.Xml.Linq;
<#	
var enums = ns.Types.OfType<CodeTypeDeclaration>().Where(tt=>tt.IsEnum).ToList();
foreach (var t in enums) { 
#>
    [DataTypeId(DataTypeIds.<#= t.Name #>)]
    public enum <#= t.Name #>
    {   
<# foreach (var f in t.Members.OfType<CodeMemberField>()) { #>        <#= f.Name.Replace('_','=') #>,
<#	} #>    }
<#	
} 
#><#	
var classes = ns.Types.OfType<CodeTypeDeclaration>().Where(tt=>tt.IsClass
    && tt.Name != "DataValue" && tt.Name != "DiagnosticInfo" && tt.Name != "ExpandedNodeId"
    && tt.Name != "ExtensionObject" && tt.Name != "Guid" && tt.Name != "LocalizedText"
    && tt.Name != "NodeId" && tt.Name != "QualifiedName" && tt.Name != "StatusCode"
    && tt.Name != "Variant" && tt.Name != "XElement" && !tt.Name.StartsWith("ListOf")).ToList();
foreach (var c in classes) { 
    var props = c.Members.OfType<CodeMemberProperty>().Where(pp=>!pp.Name.EndsWith("Specified")).ToList(); 
#>
    [BinaryEncodingId(ObjectIds.<#= c.Name #>_Encoding_DefaultBinary)]
    [XmlEncodingId(ObjectIds.<#= c.Name #>_Encoding_DefaultXml)]
    [DataTypeId(DataTypeIds.<#= c.Name #>)]
    public class <#= c.Name #><#= RenderBaseTypes(c) #>
    {
<# foreach (var p in props) { #>        public <#= RenderType(p.Type) #> <#= p.Name #> { get; set; }
<# } #><#		
if (c.BaseTypes.Count == 0) { 
#>        public virtual void Encode(IEncoder encoder)
        {
            encoder.PushNamespace("http://opcfoundation.org/UA/2008/02/Types.xsd");
<# foreach (var p in props) { #>            encoder.Write<#= RenderMethodSuffix(p.Type, enums) #>("<#= p.Name #>", <#= p.Name #>);
<# } #>            encoder.PopNamespace();
        }
        public virtual void Decode(IDecoder decoder)
        {
            decoder.PushNamespace("http://opcfoundation.org/UA/2008/02/Types.xsd");
<# foreach (var p in props) { #>            <#= p.Name #> = decoder.Read<#= RenderMethodSuffix(p.Type, enums) #>("<#= p.Name #>");
<# } #>            decoder.PopNamespace();
        }
<# } else { #>        public override void Encode(IEncoder encoder)
        {
            base.Encode(encoder);
            encoder.PushNamespace("http://opcfoundation.org/UA/2008/02/Types.xsd");
<# foreach (var p in props) { #>            encoder.Write<#= RenderMethodSuffix(p.Type, enums) #>("<#= p.Name #>", <#= p.Name #>);
<# } #>            encoder.PopNamespace();
        }
        public override void Decode(IDecoder decoder)
        {
            base.Decode(decoder);
            decoder.PushNamespace("http://opcfoundation.org/UA/2008/02/Types.xsd");
<# foreach (var p in props) { #>            <#= p.Name #> = decoder.Read<#= RenderMethodSuffix(p.Type, enums) #>("<#= p.Name #>");
<# } #>            decoder.PopNamespace();
        }
<# } #>    }
<# } #>}
<# 
}
finally
{
    if (reader != null)
        reader.Dispose();
}
#><#+
ISet<string> UaClasses { get; set; }

string RenderType(CodeTypeReference t) 
{
    var questionMark = IsClass(t.BaseType) ? "?" : "";
    var name = GetShortName(t.BaseType); 
    if (t.ArrayRank > 0)
    {
        if (t.ArrayElementType.ArrayRank > 0)
        {
            // for case of ByteStringArray to render as 'Byte[]?[]?'
            return string.Format("{0}{1}[]?[]?", name, questionMark);
        }
        return string.Format("{0}{1}[]?", name, questionMark);
    }
    return string.Format("{0}{1}", name, questionMark);
}

bool IsClass(string name)
{
    Type type = Type.GetType(name, throwOnError: false);
    if (type != null && !type.IsValueType)
        return true;
    return UaClasses.Contains(name);
}

string RenderBaseTypes(CodeTypeDeclaration type) 
{
    var types = type.BaseTypes;
    var sb = new StringBuilder();
    var flag = false;
    var isNotificationData = false;
    foreach (var t in types.OfType<CodeTypeReference>())
    {
        sb.Append(!flag ? " : " : ", "); 
        sb.Append(GetShortName(t.BaseType));
        flag = true;

        if(GetShortName(t.BaseType) == "NotificationData")
        {
          isNotificationData = true;
        }
    }


    if(GetShortName(type.Name).EndsWith("Notification"))
    {
        isNotificationData = true;
    }

    if (flag)
    {
        return isNotificationData ? $"{sb.ToString()}, INotification" : sb.ToString();
    }

    var props = type.Members.OfType<CodeMemberProperty>().ToList(); 
    var isRequest = props.Any(pp=>pp.Name == "RequestHeader");
    if (isRequest)
    {
        var responseName = $"{type.Name.Replace("Request", "Response")}";

        return $" : IServiceRequest, IRequest<{responseName}>";
    }
    var isResponse = props.Any(pp=>pp.Name == "ResponseHeader");
    if (isResponse)
    {
        return " : IServiceResponse";
    }

    return isNotificationData ? $" : IEncodable, INotification" : " : IEncodable" ;
}

string RenderMethodSuffix(CodeTypeReference type, List<CodeTypeDeclaration> knownEnums) 
{
    var name = GetShortName(type.BaseType); 
    switch (name)
    {
        case "Boolean":
            return type.ArrayRank == 0 ? "Boolean" : "BooleanArray";
        case "SByte":
            return type.ArrayRank == 0 ? "SByte" : "SByteArray";
        case "Byte":
            return type.ArrayRank == 0 ? "Byte" : (type.ArrayElementType.ArrayRank == 0 ? "ByteString" : "ByteStringArray");
        case "Int16":
            return type.ArrayRank == 0 ? "Int16" : "Int16Array";
        case "UInt16":
            return type.ArrayRank == 0 ? "UInt16" : "UInt16Array";
        case "Int32":
            return type.ArrayRank == 0 ? "Int32" : "Int32Array";
        case "UInt32":
            return type.ArrayRank == 0 ? "UInt32" : "UInt32Array";
        case "Int64":
            return type.ArrayRank == 0 ? "Int64" : "Int64Array";
        case "UInt64":
            return type.ArrayRank == 0 ? "UInt64" : "UInt64Array";
        case "Single":
            return type.ArrayRank == 0 ? "Float" : "FloatArray";
        case "Double":
            return type.ArrayRank == 0 ? "Double" : "DoubleArray";
        case "String":
            return type.ArrayRank == 0 ? "String" : "StringArray";
        case "DateTime":
            return type.ArrayRank == 0 ? "DateTime" : "DateTimeArray";
        case "Guid":
            return type.ArrayRank == 0 ? "Guid" : "GuidArray";
        case "XElement":
            return type.ArrayRank == 0 ? "XElement" : "XElementArray";
        case "NodeId":
            return type.ArrayRank == 0 ? "NodeId" : "NodeIdArray";
        case "ExpandedNodeId":
            return type.ArrayRank == 0 ? "ExpandedNodeId" : "ExpandedNodeIdArray";
        case "StatusCode":
            return type.ArrayRank == 0 ? "StatusCode" : "StatusCodeArray";
        case "QualifiedName":
            return type.ArrayRank == 0 ? "QualifiedName" : "QualifiedNameArray";
        case "LocalizedText":
            return type.ArrayRank == 0 ? "LocalizedText" : "LocalizedTextArray";
        case "ExtensionObject":
            return type.ArrayRank == 0 ? "ExtensionObject" : "ExtensionObjectArray";
        case "DataValue":
            return type.ArrayRank == 0 ? "DataValue" : "DataValueArray";
        case "Variant":
            return type.ArrayRank == 0 ? "Variant" : "VariantArray";
        case "DiagnosticInfo":
            return type.ArrayRank == 0 ? "DiagnosticInfo" : "DiagnosticInfoArray";
        // special cases to support encoding IEncodable as ExtensionObject
        case "UserIdentityToken":
            return type.ArrayRank == 0 ? "ExtensionObject<UserIdentityToken>" : "ExtensionObjectArray<UserIdentityToken>";
        case "NodeAttributes":
            return type.ArrayRank == 0 ? "ExtensionObject<NodeAttributes>" : "ExtensionObjectArray<NodeAttributes>";
        case "FilterOperand":
            return type.ArrayRank == 0 ? "ExtensionObject<FilterOperand>" : "ExtensionObjectArray<FilterOperand>";
        case "HistoryBase":
            return type.ArrayRank == 0 ? "ExtensionObject<HistoryBase>" : "ExtensionObjectArray<HistoryBase>";
        case "HistoryReadDetails":
            return type.ArrayRank == 0 ? "ExtensionObject<HistoryReadDetails>" : "ExtensionObjectArray<HistoryReadDetails>";
		case "HistoryUpdateDetails":
            return type.ArrayRank == 0 ? "ExtensionObject<HistoryUpdateDetails>" : "ExtensionObjectArray<HistoryUpdateDetails>";
        case "MonitoringFilter":
            return type.ArrayRank == 0 ? "ExtensionObject<MonitoringFilter>" : "ExtensionObjectArray<MonitoringFilter>";
        case "MonitoringFilterResult":
            return type.ArrayRank == 0 ? "ExtensionObject<MonitoringFilterResult>" : "ExtensionObjectArray<MonitoringFilterResult>";
        case "NotificationData":
            return type.ArrayRank == 0 ? "ExtensionObject<NotificationData>" : "ExtensionObjectArray<NotificationData>";
        case "DiscoveryConfiguration":
            return type.ArrayRank == 0 ? "ExtensionObject<DiscoveryConfiguration>" : "ExtensionObjectArray<DiscoveryConfiguration>";

		case "PublishedDataSetSourceDataType":
            return type.ArrayRank == 0 ? "ExtensionObject<PublishedDataSetSourceDataType>" : "ExtensionObjectArray<PublishedDataSetSourceDataType>";
		case "DataSetWriterTransportDataType":
            return type.ArrayRank == 0 ? "ExtensionObject<DataSetWriterTransportDataType>" : "ExtensionObjectArray<DataSetWriterTransportDataType>";
		case "DataSetWriterMessageDataType":
            return type.ArrayRank == 0 ? "ExtensionObject<DataSetWriterMessageDataType>" : "ExtensionObjectArray<DataSetWriterMessageDataType>";
		case "WriterGroupTransportDataType":
            return type.ArrayRank == 0 ? "ExtensionObject<WriterGroupTransportDataType>" : "ExtensionObjectArray<WriterGroupTransportDataType>";
		case "WriterGroupMessageDataType":
            return type.ArrayRank == 0 ? "ExtensionObject<WriterGroupMessageDataType>" : "ExtensionObjectArray<WriterGroupMessageDataType>";
		case "NetworkAddressDataType":
            return type.ArrayRank == 0 ? "ExtensionObject<NetworkAddressDataType>" : "ExtensionObjectArray<NetworkAddressDataType>";
		case "ConnectionTransportDataType":
            return type.ArrayRank == 0 ? "ExtensionObject<ConnectionTransportDataType>" : "ExtensionObjectArray<ConnectionTransportDataType>";
		case "ReaderGroupTransportDataType":
            return type.ArrayRank == 0 ? "ExtensionObject<ReaderGroupTransportDataType>" : "ExtensionObjectArray<ReaderGroupTransportDataType>";
		case "ReaderGroupMessageDataType":
            return type.ArrayRank == 0 ? "ExtensionObject<ReaderGroupMessageDataType>" : "ExtensionObjectArray<ReaderGroupMessageDataType>";
		case "DataSetReaderTransportDataType":
            return type.ArrayRank == 0 ? "ExtensionObject<DataSetReaderTransportDataType>" : "ExtensionObjectArray<DataSetReaderTransportDataType>";
		case "DataSetReaderMessageDataType":
            return type.ArrayRank == 0 ? "ExtensionObject<DataSetReaderMessageDataType>" : "ExtensionObjectArray<DataSetReaderMessageDataType>";
		case "DataTypeDefinition":
            return type.ArrayRank == 0 ? "ExtensionObject<DataTypeDefinition>" : "ExtensionObjectArray<DataTypeDefinition>";
			
        default:
            if(knownEnums.Any(tt=>tt.Name == name))
            {
                return type.ArrayRank == 0 ? string.Format("Enumeration<{0}>", name) : string.Format("EnumerationArray<{0}>", name);
            }
            return type.ArrayRank == 0 ? string.Format("Encodable<{0}>", name) : string.Format("EncodableArray<{0}>", name);
    }
}

string GetShortName(string name)
{
    if (name == null) return null;
    return name.Substring(name.LastIndexOf('.') + 1);
} 

#>